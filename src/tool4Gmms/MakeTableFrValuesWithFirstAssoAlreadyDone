package tool4Gmms;
import java.util.ArrayList;
import java.io.*;
import java.util.HashMap;
import java.util.Iterator;
import java.util.Map;
import java.lang.Math;
import java.util.Set;
import java.util.HashSet;
import www.spatial.maine.edu.assignment.HungarianAlgorithm;
import edu.umass.cs.mallet.base.pipe.iterator.AbstractPipeInputIterator;
import edu.umass.cs.mallet.base.types.Instance;
import org.apache.commons.math3.stat.descriptive.moment.Mean;
import org.apache.commons.math3.stat.descriptive.moment.StandardDeviation;
import edu.umass.cs.mallet.grmm.learning.ACRF;
public class MakeTableFrValues  extends AbstractPipeInputIterator{

    private HashMap<String,String> association;
    private	ArrayList<String> segmentNames=new ArrayList<String> ();
    private	ArrayList<String> labels= new ArrayList<String> ();
    private	ArrayList<Integer> segmentIdx =new ArrayList<Integer> ();
    private	ArrayList<String> types= new ArrayList<String> ();
    private	HashMap<String,Integer> segmentOrder = new HashMap<String,Integer>();
    private	HashMap<String,Integer> labelIdx;
    private int nAudio;
    private int nVid;
    private int nvModels;
    private double[][] pCostTable;
    private double[][] aVCostTable;
    private double[][] hsCostTable;
    private double[][] ladCostTable;
    private double[][] posCostTable;
    private double[][] aCostTable;
    private double[][] vCostTable;
    private double[][] vCostTableSift;
    private ACRF.Template[] templates;
    private ArrayList<String> shows;
    private String dir;
    private int nextShow;
    private int iterNumber=-1;

    public MakeTableFrValues(String dir,int iterNumber, ArrayList<String> shows, ACRF.Template[] templates)throws Exception{
	this.iterNumber=iterNumber;
	this.dir=dir;
	this.templates=templates;
	this.shows=shows;
	nextShow=0;
    }
    public InstanceRepere loadMapping(String mapFileName)throws Exception{
	segmentNames=new ArrayList<String> ();
	labels= new ArrayList<String> ();
	segmentIdx =new ArrayList<Integer> ();
	types= new ArrayList<String> ();
	segmentOrder = new HashMap<String,Integer>();
	labelIdx= new HashMap<String,Integer> ();
	String line, pattern="[ ]+";
	String[] tokens;
	BufferedReader in = new BufferedReader(new FileReader(mapFileName));
	int lIdx=0;
	while((line = in.readLine())!=null){
	    tokens=line.split(pattern);
	    labels.add(tokens[0]);
	    segmentNames.add(tokens[1]);
	    segmentIdx.add(new Integer((new Double(tokens[2])).intValue()));
	    segmentOrder.put(tokens[1],new Integer((new Double(tokens[2])).intValue()));
	    types.add(tokens[3]);
	    if(!labelIdx.containsKey(tokens[0])){
		labelIdx.put(tokens[0],new Integer(lIdx));
		lIdx+=1;
	    }
	}
	return new InstanceRepere(segmentNames,labels,segmentIdx,types,segmentOrder,labelIdx);
    }
    public void setAVScore (String avcostFile, InstanceRepere carrier)throws Exception{
		String line;
		String pattern="[ ]+";
		String[] tokens;
		aVCostTable=new double[carrier.getNumUtterances()][carrier.getNumFaceTracks()];
		hsCostTable=new double[carrier.getNumUtterances()][carrier.getNumFaceTracks()];
		ladCostTable=new double[carrier.getNumUtterances()][carrier.getNumFaceTracks()];
		posCostTable=new double[carrier.getNumUtterances()][carrier.getNumFaceTracks()];
		for(int i=0;i<aVCostTable.length;i++)
		    for(int j=0;j<aVCostTable[0].length;j++){
		    	aVCostTable[i][j]=-9999;
		    	hsCostTable[i][j]=-9999;
		    	ladCostTable[i][j]=-9999;
		    	posCostTable[i][j]=-9999;
		    }
		BufferedReader in = new BufferedReader(new FileReader(avcostFile));
		while((line = in.readLine())!=null){
		    tokens=line.split(pattern);
		    String utterName=tokens[2];
		    int uttIdx=(int)segmentOrder.get(utterName);
		    String trackName=tokens[3];
		    int trackIdx = (int)segmentOrder.get(trackName);
		    for(int i=0;i<templates.length;i++){
		    	if(templates[i] instanceof ACRF.HeadSizeTemplate){
		    	    double value = Double.parseDouble(tokens[15]);
		    	    hsCostTable[uttIdx][trackIdx]=value;
		    	}
		    	if(templates[i] instanceof ACRF.LadTemplate){
		    	    double value = Double.parseDouble(tokens[16]);
		    	    ladCostTable[uttIdx][trackIdx]=value;
		    	}
		    	if(templates[i] instanceof ACRF.PosTemplate){
		    	    double value = Double.parseDouble(tokens[17]);
		    	    posCostTable[uttIdx][trackIdx]=value;
		    	}
		    	if(templates[i] instanceof ACRF.FusionTemplate){
		    	    double value = Double.parseDouble(tokens[14]);
		    	    aVCostTable[uttIdx][trackIdx]=value;
		    	}
	
		    }
		}
		carrier.setAvCostTable(aVCostTable);
		carrier.setHsCostTable(hsCostTable);
		carrier.setLadCostTable(ladCostTable);
		carrier.setPosCostTable(posCostTable);
	    for(int i=0;i<templates.length;i++){
	    	if(templates[i] instanceof ACRF.HeadSizeTemplate){
	    	    continue;
	    	    //carrier.dumpHsTable(iterNumber); not implemented
	    	}
	    	if(templates[i] instanceof ACRF.LadTemplate){
	    	    carrier.dumpLadTable(iterNumber);
	    	    continue;
	    	}
	    	if(templates[i] instanceof ACRF.PosTemplate){
	    	    continue;
	    	}
	    	if(templates[i] instanceof ACRF.FusionTemplate){
	    	    carrier.dumpAVTable(iterNumber);
	    	}
	
	    }
    }
    public void setAScore(String aScoreFile,InstanceRepere carrier) throws Exception{
	FileInputStream fileIn = new FileInputStream(aScoreFile);
	ObjectInputStream in2 = new ObjectInputStream(fileIn);
	double[][] aCostTable=getTNorm((double[][]) in2.readObject());
	HashMap<String,Integer> utterOrder = (HashMap<String,Integer>) in2.readObject();
	HashMap<String,Integer> aModelOrder = (HashMap<String,Integer>) in2.readObject();
	double[][] reshapedACostTable = new double[carrier.getNumUtterances()][labelIdx.size()];
	HashSet<String> noModel=new HashSet<String>();
	for(int i=0;i<segmentNames.size();i++){
	    if(types.get(i).equals("utter")){
			String segName=segmentNames.get(i);
			int idxSeg = (int)segmentOrder.get(segName);
			if(utterOrder.containsKey(segName)){
			    int idxUtter=(int)utterOrder.get(segName);
			    for (Map.Entry<String, Integer> entry : labelIdx.entrySet()){ //refaire la boucle, iterer sur les aModelOrder
					String label= entry.getKey();
					if(aModelOrder.containsKey(label)){
					    int idxModel=(int)aModelOrder.get(label);
					    reshapedACostTable[idxSeg][entry.getValue()]=aCostTable[idxUtter][idxModel];
					}
					else{//put a null model
					    reshapedACostTable[idxSeg][entry.getValue()]=0.46589;
					    noModel.add(entry.getKey());
					}
			    }
			}
	    }
	}
	System.out.println(noModel.size()+" labels don't have acoustic models");
	carrier.setACostTable(reshapedACostTable);
    }
    public double[][] getTNorm(double[][] costTable){
	double[][] tNormedTable=new double[costTable.length][costTable[0].length];
	Mean m=new Mean();
	StandardDeviation std = new StandardDeviation();
	for(int i=0;i<costTable.length;i++){
	    double mean=m.evaluate(costTable[i],0,costTable[i].length);
	    double devi=std.evaluate(costTable[i],mean);
	    for(int j=0;j<costTable[i].length;j++)
		tNormedTable[i][j]=(costTable[i][j]-mean)/devi;
	}
	return tNormedTable;
    }
    public void setVScore(String vcostFile, InstanceRepere carrier)throws Exception{
	String line;
	String pattern="[ ]+";
	String[] tokens;
	BufferedReader in = new BufferedReader(new FileReader(vcostFile));
	//read the first line and get the cluster names
	line = in.readLine();
	tokens=line.split(pattern);
	nvModels=tokens.length;
	HashMap<String,Integer> vModelOrder= new HashMap<String,Integer>();
	for(int i=0;i<nvModels;i++){
	    vModelOrder.put(tokens[i],i);
	}
	in.mark(10000000);//retain the position of the second line
	//read all the lines to associate the track to their cluster names
	int trackId=0;
	HashMap<String,Integer> trackOrder= new HashMap<String,Integer>();
	while((line = in.readLine())!=null){
	    tokens=line.split(pattern);
	    String trackName=tokens[0];
	    String clusName=tokens[1];
	    trackOrder.put(trackName,trackId);
	    trackId++;
	}
	in.reset();// get back on the second line to read a second time
	vCostTable=new double[trackOrder.size()][nvModels];
	while((line = in.readLine())!=null){
	    tokens=line.split(pattern);
	    String trackName=tokens[0];
	    for(int i=0;i<nvModels;i++){
		double score=Double.parseDouble(tokens[i+2]);
		vCostTable[trackOrder.get(trackName)][i]=score;
	    }
	}
	double[][] normedTable=getTNorm(vCostTable);//get stats for tNorm normalisation(roy Wallace2012)
	//double[][] normedTable=vCostTable;
	double[][] reshapedVCostTable = new double[carrier.getNumFaceTracks()][labelIdx.size()];
	HashSet<String> noModel=new HashSet<String>();
	for(int i=0;i<segmentNames.size();i++){
	    if(types.get(i).equals("faceTrack")){
		String segName=segmentNames.get(i);
		int idxSeg = (int)segmentOrder.get(segName);
		if(trackOrder.containsKey(segName)){
		    int idxTrack=(int)trackOrder.get(segName);
		    for (Map.Entry<String, Integer> entry : labelIdx.entrySet()){ //iterer sur modeleOrder
				String label = entry.getKey();
				if(vModelOrder.containsKey(label)){
				    int idxModel=(int)vModelOrder.get(label);
				    reshapedVCostTable[idxSeg][entry.getValue()]=normedTable[idxTrack][idxModel];
				}
				else{//put a null model
				    reshapedVCostTable[idxSeg][entry.getValue()]=0.41;//threshold that maximise EER on development set
				    noModel.add(entry.getKey());
				}
		    }
		}
		else
		    for (Map.Entry<String, Integer> entry : labelIdx.entrySet())
		    	reshapedVCostTable[idxSeg][entry.getValue()]=0.41;
	    }
	}
	carrier.setVCostTable(reshapedVCostTable);
	System.out.println(noModel.size()+" labels don't visual have models");
    }
    public void setVScore2(String vcostFile, InstanceRepere carrier)throws Exception{
	double[][] vCostTable = new double[carrier.getNumFaceTracks()][labelIdx.size()];
	for(int i=0;i<vCostTable.length;i++)
	    for(int j=0;j<vCostTable[0].length;j++)
		vCostTable[i][j]=-0.928285019239;
	String line;
	String pattern="[ ]+";
	String[] tokens;
	BufferedReader in = new BufferedReader(new FileReader(vcostFile));
	while((line = in.readLine())!=null){
	    tokens=line.split(pattern);
	    String trackName=tokens[0];
	    String clusName=tokens[1];
	    double value=(double)(new Double(tokens[2]));
	    int idxLabel = labelIdx.get(clusName);
	    int idxTrack = segmentOrder.get(trackName);
	    vCostTable[idxTrack][idxLabel]=value;
	}
	carrier.setVSiftCostTable(vCostTable);
    }

    public void setPScore(String vcostFile, InstanceRepere carrier)throws Exception{
	double[][] pCostTable = new double[carrier.getNumFaceTracks()][carrier.getNumFaceTracks()];
	String line;
	String pattern="[ ]+";
	String[] tokens;
	BufferedReader in = new BufferedReader(new FileReader(vcostFile));
	while((line = in.readLine())!=null){
	    tokens=line.split(pattern);
	    int idxT1= (int)segmentOrder.get(tokens[0]);
	    int idxT2= (int)segmentOrder.get(tokens[1]);
	    double score = (double)(new Double(tokens[2]));
	    pCostTable[idxT1][idxT2]=score;
	    pCostTable[idxT2][idxT1]=score;//need to duplicate because after I don't want to care about which value is where
	}
	carrier.setPCostTable(pCostTable);
    }
    public InstanceRepere nextInstance(){
	assert (nextShow != -1);
	InstanceRepere carrier = getInstanceForShow(nextShow);
	nextShow = getNextShow();
	return carrier;
    }
    public int getNextShow(){
	if(nextShow==(shows.size()-1))
	    return -1;
	else{
	    nextShow=nextShow+1;
	    return nextShow;
	}
    }
    public boolean hasNext (){
	return nextShow!=-1;
    }
    public InstanceRepere getInstanceForShow(int nextShow){
	String currentShow=shows.get(nextShow);
	String aScoreFile,vScoreFile, avScoreFile,pScoreFile,vSiftScoreFile;
	InstanceRepere carrier=null;
	System.out.println("getting instance for show: "+currentShow);
	if(iterNumber==-1){// in this case it is for training data
	    aScoreFile = dir+"/audio/models/"+currentShow+".atableser";
	    vSiftScoreFile=dir+"/video/distSurf/"+currentShow+".vtablesift";
	    vScoreFile=dir+"/video/models/"+currentShow+"/modelsAndScore/"+currentShow+".vtable";
	    avScoreFile = dir+"/fusion/"+currentShow+".value4dec";
	    pScoreFile = dir+"/video/distSurf/"+currentShow+".score";
	}
	else{//testing case
	    //	    initialiseSegmentAndLabels(dir+"/crfOutputs/iter"+(iterNumber-1)+"/"+currentShow+".mapping")
	    aScoreFile = dir+"/audio/iter"+iterNumber+"/"+currentShow+".atableser";
	    vScoreFile = dir+"/video/iter"+iterNumber+"/"+currentShow+"/modelsAndScore/"+currentShow+".vtable";
	    vSiftScoreFile=dir+"/video/distSurf/iter"+iterNumber+"/"+currentShow+".vtablesift";
	    avScoreFile = dir+"/fusion/iter"+iterNumber+"/"+currentShow+".value4dec";
	    pScoreFile = dir+"/video/dist/"+currentShow+".score";
	}
	try{
	    if(iterNumber==1 || iterNumber==-1)
	    	carrier=loadMapping(dir+"/"+currentShow+".initList");
	    else
	    	carrier=loadMapping(dir+"/crfOutputs/iter"+(iterNumber-1)+"/"+currentShow+".mapping");
	    carrier.setDir(this.dir);
	    carrier.setName(currentShow);
	    for(int i=0;i<templates.length;i++){
	    	if(templates[i] instanceof ACRF.FusionTemplate){
	    	    setAVScore(avScoreFile,carrier);
	    	}
	    }
	    for(int i=0;i<templates.length;i++){
	    	if(templates[i] instanceof ACRF.AcousticTemplate){
	    		setAScore(aScoreFile,carrier);
		    	carrier.dumpATable(iterNumber);
	    	}
	    	if(templates[i] instanceof ACRF.VisualTemplate){
	    		setVScore(vScoreFile,carrier);
	    	    carrier.dumpVTable(iterNumber);
	    	}
	    	if(templates[i] instanceof ACRF.VisualTemplateSift){
	    		setVScore2(vSiftScoreFile,carrier);
	    		carrier.dumpVTableSift(iterNumber);
	    	}
	    	if(templates[i] instanceof ACRF.SimSiftTemplate)
	    		setPScore(pScoreFile,carrier);
	    }
	    carrier.setName(currentShow);
	    carrier.setDir(this.dir);

	    //carrier.dumpPTable();
	}
	catch(Exception e){e.printStackTrace();}
	return carrier;
    }
    public void dumpAVCostTable(String show)throws Exception{
	FileWriter fstream = new FileWriter(show+".avtable");
	BufferedWriter out = new BufferedWriter(fstream);
	/*Iterator it = utterOrder.entrySet().iterator();
		while (it.hasNext()) {
	    Map.Entry pairs = (Map.Entry)it.next();
	    out.write(((String)pairs.getKey()));
	    Iterator it2 = trackOrder.entrySet().iterator();
	    while (it2.hasNext()) {
		Map.Entry pairs2 = (Map.Entry)it2.next();
		out.write(((String)pairs.getKey())+" "+((String)pairs2.getKey())+" "+aVCostTable[((Integer)pairs.getValue())][((Integer)pairs2.getValue())]);
		out.write("\n");
	    }
	    }*/
	out.close();
    }
    public void dumpAssocMatrix(ArrayList<String> speakerList, ArrayList<String> headList, double[][] costMatrix)throws Exception{
	FileWriter fstream = new FileWriter(dir+"/fusion/iter"+iterNumber+"/"+shows.get(nextShow)+".assocMatrix");
	BufferedWriter out = new BufferedWriter(fstream);
	out.write(speakerList.get(0));
	for (int i = 1; i < speakerList.size(); i++) {
	    out.write(" "+speakerList.get(i));
	}
	out.write("\n");
	out.write(headList.get(0));
	for (int i = 1; i < headList.size(); i++) {
	    out.write(" "+headList.get(i));
	}
	out.write("\n");
	for (int i = 0; i < speakerList.size(); i++) {
	    out.write( Double.toString(costMatrix[i][0]));
	    for (int j = 1; j < headList.size(); j++) {
		out.write( Double.toString(costMatrix[i][j]));
	    }
	    out.write("\n");
	}
	out.close();
    }
    public HashMap<String,String> getAssociation(){return association;}
    public double[][] getAtable(){return aCostTable;}
    public static void main(String args[]){
	double[][] q={{1,1,2,2},{4,5,6,7}};
	double[] a=q[0];
	Mean m =new Mean();
	System.out.println(m.evaluate(q[0],0,q[0].length));
	//	System.out.println(Mean.evaluate(q[1],0,q.length));
    }
}
